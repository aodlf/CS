// 비트 연산자
using System;

namespace Chap03_04
{
    class Program
    {
        static void Main(string[] args)
        {
            int x = 61;
            // 0000 0000 0000 0000 0000 0000 0011 1101(2)
            // 0    0    0    0    0    0    3    D(16)   

            int y = 55; 
            // 0    0    0    0    0    0    3    7(16)

            // 0000 0000 0000 0000 0000 0000 0011 1101(2)
            // 0000 0000 0000 0000 0000 0000 0011 0111(2)
            //|0000 0000 0000 0000 0000 0000 0011 1111(2) <--- & bit or연산 후 메모리에 저장된 값
            //                    1 + 2 + 4 + 8 + 16 + 32 = 63(10)
            //                               3 F (16)

            //&0000 0000 0000 0000 0000 0000 0011 0101(2) <--- & bit and연산 후 메모리에 저장된 값
            //                    1 + 4 + 16 + 32 = 53(10)
            //                               3 5 (16)

            // ^, 배타적 논리합, Exclusive Or
            Console.WriteLine(x ^ y);
            Console.WriteLine("{0:X8}", x ^ y);
            // 0000 0000 0000 0000 0000 0000 0011 1101(2) 61(10)
            // 0000 0000 0000 0000 0000 0000 0011 0111(2) 55(10)
            //^0000 0000 0000 0000 0000 0000 0000 1010(2) <--- & bit exclusive or연산 후 메모리에 저장된 값
            //                                      10(10)
            //                                       A(16)

            Console.WriteLine(x & y); // 10
            Console.WriteLine("{0:X8}", x & y); // A
            Console.WriteLine(x | y); // 63
            Console.WriteLine("{0:X8}", x | y); // 3F

            // 0000 0000 0000 0000 0000 0000 0011 1101(2) 61(10)
            //~1111 1111 1111 1111 1111 1111 1100 0010(2) 맨 앞자리 1 -> 음수 , 1의 보수 , -62(10)
            // F    F    F    F    F    F    C    2(16)

            // 0000 0000 0000 0000 0000 0000 0011 1110(2) 62(10)

            // 1의 보수법, 2의 보수법, 음수 표현 방식

            Console.WriteLine(~x); // -62(10)
            Console.WriteLine("{0:X8}", ~x); // FFFFFFC2(16)
        }
    }
}
